1. java.lang 패키지
java.lang 패키지는 기본이 되는 패키지, 그래서 Import 문이 필요가 없다. 

1.1 Object클래스
최고 조상 클래스

protected Object clone()	객체 자신의 복사본을 만든다.
public boolean equals(Object obj)	객체 자신과 객체 obj가 같은 객체인지 알려 준다. (같은면 true)
protected void finalize()	객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야 하는 콛가 있을 때 오버라이딩한다. 
public Class getClass()	객체 자신의 클래스 정보를 담고 있는 Class인스턴스를 반환한다. 
public int hashCode()		객체 자자신의 해시코드를 반환한다. 
public String toString()	객체 ㅔ자신의 정보를 문자열로 반환한다. 
public void notify()		객체 자신을 사용라려고 기다리는 쓰레드를 하나만 깨운다. 
public void notifyAll()		객체 자신을 사용라려고 기다리는 모든 쓰레드를 깨운다.
public void wait()		다른쓰레드가 notify() , notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간동안 기다리게 한다.  public void wait(long timeout), 	public void wait(long timeout, int nanos)


equals(Object obj)
매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean값으로 알려 주는 역할을 한다. 
Object클래스로부터 상속받은 equals메서드는 결국 두 개의 참조변수가 같은 책체를 참조하고 있는지, 즉 두 참조변수에 저장된 값(주소값)이 같은지를 판단하는 기능밖에 할 수 없다는 것을 알 수 있다. 

hashCode()
해싱 기법에 사용되는 '해시함수'를 구현한 것이다. 
해싱은 데이터관리기법 중의 하나인데 다량의 데이터를 저장하고 검색하는 데 유용하다. 
해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다. 

toString()
이 메서드는 인스턴스에 대한 정보를 문자열로 제공할 목적으로 정의된 것이다. 
public String toString(){
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}

clone()
이 메서드는 자신을 복제하여 새로운 인ㅅ턴스를 생성하는 일을 한다. (clone() 은 Interface 즉 Cloneable을 구현해야 한다. )
어떤 인스턴스에 대해 작업을 할 때, 원래의 인스턴스를 보존하고 clone메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업이전의 값이 보전되므로 작업에 실패해서 원래의 상태로 되돌리거나 변경도지 전의 값을 참고하는데 도움이 될 것이다. 
Object클래스에 정의된 clone()은 단순히 인스턴스변수의 값만 복사하기 때문에 참조타입의 인스턴스 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다.  배열의 경우 참조변수 이므로, 참조 변수의 경우 원래의 인스턴스에 영향을 미치게 된다. 
이럴 경우는 clone 메서드를 오버라이딩해서 새로운 배열을 생성하고 배열의 내용을 복사하도록 해야 한다. 

clone 을 사용하려면, 먼저 복제할 클래스가 Cloneable인터페이스를 구현해야 하고 , clone()을 오버라이딩하면서 접근 제어자를 Portected에서 public 으로 변경해야 한다. 

getClass()
이 메서드는 자신이 속한 클래스의 Class객체를 반환하는 메서드인데, Class객체는 이름이 "Class"인 클래스의 객체이다.  (동적인 코드 작성에 좋음) 
public final class Class implements ... {... .}

Class 객체를 얻는 방법
Class cObj = new Card().getClass();  // 생성된 객체로 부터 얻는 방법
Class cObj = Card.class;		//클래스 리터럴(*.class) 로 부터 얻는 방법
Class cObj = Class.forName("Card");	// 클래스 이름으로 부터 얻는 방법


Card c = new Card();		// New 연산자를 이용해서 객체를 생성하는 방법이며
Card c = Card.class.newInstance();	// Class객체를 이용해서 객체 생성 ( newInstance()의 경우 예외처리가 필수 조건이다)

* 동적으로 객체를 생성하고 메서드를 호출하는 방법에 대해 더 알고 싶다면 "리플렉션 API(reflection API'로 검색하면 된다. 

1.2 String 클래스
java 에서는 문자열을 다루기 위한 특별한 class - String class 를 제공한다. 
String class는 문자열을 저장하고, 다루기 위한 함수를 제공한다. 

변경 불가능한(immutable) 클래스
public final class String implements java.io.Serializable, comparable {
	private char[] value;
	...
}

문자열 비교
문자열을 만들 때는 두가지 방법이 존재 ( 문자열 리터럴을 지정하는 방법과 , String클래스의 생성자를 이용해서 만드는 방법)
String str1 = "abc" ;  // 문자열 리터럴 "abc"의 주소가 str1에 저장됨.
String str2 = "abc" ; // 문자열 리터럴 "abc"의 주소가 str2에 저장됨.
String str3 = new String("abc"); // 새로운 String instance를 생성
String str4 = new String("abc"); // 새로운 String instance를 생성
문자열 리터럴은 이미 존재하는 것을 재사용하는 것이며 , New 생성자는 instance를 새로 메모리에 만들어 주는 역할을 한다. 

equals() 를 사용하면 두 문자열의 내용을 비굑하기 때문에 리터럴과 new 모두 true로 나타낸다. 
그러나 String instance의 주소를 등가비교연산자 '=='로 비교했을 때는 결과가 다르다. 

문자열 리터럴
자소 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 이 때 같은 내용의 문자열 리터럴은 한번만 저장된다. 
문자열 리터럴도 String instance이고 한번 생성하면 내용을 변경할 수 없으니 하나의 인스턴스를 공유하면 되기 때문이다. 

빈 문자열(empty string)

String 클래스의 생성자와 메서드
String(String s) : 주어진 문자열(s)를 갖는 String 인스턴스를 생성한다. --> String s = new String("Hello") --> S = "Hello"
String(char[] value) : 주어진 문자열(value)을 갖는 String 인스턴스를 생성
	char[] c = { 'H', 'e', 'l','l','o' };
	String s = new String(c);
	--> s = "Hello"
String (StringBuffer buf) : StringBuffer인스턴스가 갖고 있는 문자열과 같은 내용의 String인스턴스를 생성한다. 
	StringBuffer sb = new StringBuffer("Hello");
	String s = new String(sb);
	--> s = "Hello"
char charAt(int index) : 지정된 위치(index)에 있는 문자를 알려준다. (index 는 0 부터이다.)
	String s = "Hello";
	String n = "0123456";
	char c = s.charAt(1); // c = 'e'
	char c2 = n.charAt(1); // c2 = '1'
int compareTo(String str) : 문자열(str)과 사전순서로 비교한다, 같으면 0을, 사전순으로 이전이므녀 음수를 , 이후면 양수를 반환
	int i = "aaa".compareTo("aaa"); // i = 0
	int i2 = "aaa".compareTo("bbb"); // i2= -1
	int i3 = "bbb".compareTo("aaa"); // i3 = 1

String concat (String str) :  문자열(str)을 뒤에 덧붙인다. 
	String s = "Hello";
	String s2 = s.concat(" World!"); // s2 = "Hello World!"

boolean contains(charSequence s) : 지정된 문자열(s)이 포함되었는지 검사한다. 
	String s = "abcdefg";
	boolean b = s.contains("bc");   // b = true

boolean endsWith(String suffix) : 지정된 문자열(suffix)로 끝나는지 검사한다. 
	String file = "Hello.txt";
	boolean b = file.endsWith("txt") ; // b = true
boolean equals ( Object obj) : 매개변수로 받은 문자열 (obj)과 String 인스턴스의 문자열을 비교한다 obj가 String이 아니거나 문자열이 다르면 false를 반환한다. 
	String s = "Hello";
	boolean b = s.equals("Hello");
	boolean b2 = s.equals("hello");

boolean equalsIgnoreCase(String str) : 문자열과 String 인스턴스의 문자열을 대소문자 구분없이 비교한다. 
	String s = "Hello"
	boolean b = s.equalsIgnoreCase("HELLO");
	boolean b2 = s.equalsIgnoreCase("hello");

int indexOf(char ch) : 주어진 문자(ch) 가 문자열에 존재하는지 확인하여 (index)를 알려준다. 못찾으면 -1
	String s = "Hello";
	boolean b = s.indexOf('o');
	boolean b2 = s.indexOf('k');

int indexOf(char ch, int pos) : 주어진 문자(ch)가 문자열에 존재하는지 지정된 위치(Pos)부터 확인하여 위치(index)를 알려준다. 못찾으면 -1
	String s = "Hello";
	int idx1 = s.indexOf('e', 0);
	int idx2 = s.indexOf('e',2);

int indexOf(String str) : 주어진 문자열이 존재하는지 확인하여 그 위치(index)를 알려준다. 없으면 -1
	String s = "ABCDEFG";
	int idx = s.indexOf("CD");

String intern() : 문자열 상수풀(constant pool) 에 등록한다. 이미 상수풀에 같은 내용의 문자열이 있을 경우 , 그문자열의 주소값을 반환한다		String s = new String ("abc");
	String s2 = new String("abc");
	boolean b = (s==s2);
	boolean b2 = s.equals(s2);
	boolean b3 = (s.intern() == s2.intern());

int lastIndexOf(char ch) : 지정된 문자 또는 문자코드를 문자열의 오른쪽 끝부터 찾아서 위치(index)를 알려 준다. 못찾으면 -1
	String s = "java.lang.Object";
	int idx1 = s.lastIndexOf('.') //
	int idx2 = s.indexOf('.');

int length() : 문자열의 길이를 알려준다. 

String replace ( char old, char nw) : 문자열 중 문자(Old)를 새로운 문자(Nw)로 바꾼 문자열을 반환한다. ㅏ
	String s = "Hello";
	String s1 = s.replace ('H','C');
String replace ( CharSequence old, CharSequence nw) : 문자열 중의 문자열(old)를 새로운 문자열(nw)로 모두 바꾼 문자열을 반환한다. 
	String s = "Hellollo";
	String s1 = s.replace("ll","LL");
String replaceAll(String regex, String replacement) : 문자열 중에서 지정된 문자열(regex)과 일치한 것을 새로운 문자열(replacement)로 모두 변경한다. 
	String ab = "AABBAABB"
	String r = ab.replaceAll("BB","bb");

String replaceFirst(String regex, String replacement) : 문자열 중에서 지정된 문자열(Regex)과 일치 하는 것중, 첫 번째 것만 새로운 만주열로 변경한다. 
	String ab = "AABBAABB";
	String r = ab.replaceFirst("BB","bb");
String[] split(String regex) : 문자열을 지정된 분리자(regex) 로 나누어 무자열배열에 담아 반환한다.
	String animal = "dog,cat,bear";
	String[] arr = animal.split(",");
String[] split(String regex, int limit) : 문자열을 지정된 분리자로 나누어 문자열배열에 담아 반환한다. 단 문자열 전체를 지정된 수로 자른다. 
	String animal = "dog,cat,bear";
	String[] arr = animal.split(",", 2);

boolean startsWith(String prefix) : 주언진 문자열로 시작하는지 검사한다. 
	String s = "java.lang.Object";
	boolean b = s.startsWith("java");
	boolean b2 = s.startsWith("lang");

String substring(int begin), String substring(int begin, int end)  : 주어진 시작위치부터 끝 위치 범위에 포함된 문자열을 얻는다. 이때 시작위치의 문자는 포함되지만, 끝 위치의 문자는 포함되지 않는다. 
	String s = "java.lang.Object";
	String c = s.substring(10);
	String p = s.substring(5,9);

String toLowerCase() : 소문자로 반환
String toString () : 인스턴스에 지정된 문자열을 반환한다. 
String toUpperCase() : 대문자로 반환
String trim() : 문자열의 왼쪽 끝과 오른쪽 끝에 있는 공백을 업앤 견과를 반환한다. 
static String valueOf(boolean b)
static String valueOf(cahr c)
static String valueOf(int i)
static String valueOf(long l)
static String vlaueOf(float f)
static String valueOf(double d)
static String valueOf(Object o) 
지지어된 값을 문자열로 변환하여 반홚나다. 참조변수의 경우, toString()을 호출한 결과를 반환한다. 

join() 과 StringJoiner
join()은 여러 문자열 사이에 구분자를 넣어서 결합한다. 
String animals = "dog,cat,bear";
String[] arr = animals.split(",");
String str = String.join("-",arr);
System.out.println(str);

java.util.StringJoiner클래스를 사용해서 문자열을 결합할 수도 있다. 
StringJoiner sj = new StringJoiner(",","[","]");
String[] strArr = { "aaa", "bbb", "ccc" };
for(String s : strArr )
	sj.add(s.toUpperCase());
System.out.println(sj.toString());

유니코드의 보충문자. 
유니코드는 원래 2byte 16bit 문자 체계, 그러나 지금은 20bit 로 확장되었다. 이에 char로는 감당이 아니되 int를 사용 즉 int ch가 됨

문자 인코딩 변환
getBytes(String charsetName)을 사용하면, 문자열의 문자 인코딩을 다른 인코딩으로 변경할 수 잇다. 
Java 는 UTF-16을 사용하지만, 문자열 리터럴에 포함되는 문자들은 OS 인코딩을 사용한다. 
그래서 한글 윈도우즈 인경우 문자 인코딩으로 CP949를 사용된다. 이것을 UTF-8로 변경하려면
byte[] utf8_str = "가".getBytes("UTF-8");
String str = new String(utf8_str, "UTF-8");

String.format()
format()은 형식화된 문자열을 만들어내는 간단한 방법이다. printf()하고 사용법이 완전히 똑같으므로 사용하는데 별 어려움은 없을 것이다. 
String str = String.format("%d 더하기 %d는 %d입니다",3,5,3+5);
System.out.println(str);

기본형 값을 String으로 변환 +"" 하던가 아니면 String.valueOf(i) 하던가 !!

String 을 기본형 값으로 valueOf를 쓰거나 parseInt()를 사용
int i = Integer.parseInt("100");
int i2 = Integer.valueOf("100");

