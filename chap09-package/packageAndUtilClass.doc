1. java.lang 패키지
java.lang 패키지는 기본이 되는 패키지, 그래서 Import 문이 필요가 없다. 

1.1 Object클래스
최고 조상 클래스

protected Object clone()	객체 자신의 복사본을 만든다.
public boolean equals(Object obj)	객체 자신과 객체 obj가 같은 객체인지 알려 준다. (같은면 true)
protected void finalize()	객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야 하는 콛가 있을 때 오버라이딩한다. 
public Class getClass()	객체 자신의 클래스 정보를 담고 있는 Class인스턴스를 반환한다. 
public int hashCode()		객체 자자신의 해시코드를 반환한다. 
public String toString()	객체 ㅔ자신의 정보를 문자열로 반환한다. 
public void notify()		객체 자신을 사용라려고 기다리는 쓰레드를 하나만 깨운다. 
public void notifyAll()		객체 자신을 사용라려고 기다리는 모든 쓰레드를 깨운다.
public void wait()		다른쓰레드가 notify() , notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간동안 기다리게 한다.  public void wait(long timeout), 	public void wait(long timeout, int nanos)


equals(Object obj)
매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean값으로 알려 주는 역할을 한다. 
Object클래스로부터 상속받은 equals메서드는 결국 두 개의 참조변수가 같은 책체를 참조하고 있는지, 즉 두 참조변수에 저장된 값(주소값)이 같은지를 판단하는 기능밖에 할 수 없다는 것을 알 수 있다. 

hashCode()
해싱 기법에 사용되는 '해시함수'를 구현한 것이다. 
해싱은 데이터관리기법 중의 하나인데 다량의 데이터를 저장하고 검색하는 데 유용하다. 
해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다. 

toString()
이 메서드는 인스턴스에 대한 정보를 문자열로 제공할 목적으로 정의된 것이다. 
public String toString(){
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}

clone()
이 메서드는 자신을 복제하여 새로운 인ㅅ턴스를 생성하는 일을 한다. (clone() 은 Interface 즉 Cloneable을 구현해야 한다. )
어떤 인스턴스에 대해 작업을 할 때, 원래의 인스턴스를 보존하고 clone메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업이전의 값이 보전되므로 작업에 실패해서 원래의 상태로 되돌리거나 변경도지 전의 값을 참고하는데 도움이 될 것이다. 
Object클래스에 정의된 clone()은 단순히 인스턴스변수의 값만 복사하기 때문에 참조타입의 인스턴스 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다.  배열의 경우 참조변수 이므로, 참조 변수의 경우 원래의 인스턴스에 영향을 미치게 된다. 
이럴 경우는 clone 메서드를 오버라이딩해서 새로운 배열을 생성하고 배열의 내용을 복사하도록 해야 한다. 

clone 을 사용하려면, 먼저 복제할 클래스가 Cloneable인터페이스를 구현해야 하고 , clone()을 오버라이딩하면서 접근 제어자를 Portected에서 public 으로 변경해야 한다. 

getClass()
이 메서드는 자신이 속한 클래스의 Class객체를 반환하는 메서드인데, Class객체는 이름이 "Class"인 클래스의 객체이다.  (동적인 코드 작성에 좋음) 
public final class Class implements ... {... .}

Class 객체를 얻는 방법
Class cObj = new Card().getClass();  // 생성된 객체로 부터 얻는 방법
Class cObj = Card.class;		//클래스 리터럴(*.class) 로 부터 얻는 방법
Class cObj = Class.forName("Card");	// 클래스 이름으로 부터 얻는 방법


Card c = new Card();		// New 연산자를 이용해서 객체를 생성하는 방법이며
Card c = Card.class.newInstance();	// Class객체를 이용해서 객체 생성 ( newInstance()의 경우 예외처리가 필수 조건이다)

* 동적으로 객체를 생성하고 메서드를 호출하는 방법에 대해 더 알고 싶다면 "리플렉션 API(reflection API'로 검색하면 된다. 

1.2 String 클래스
java 에서는 문자열을 다루기 위한 특별한 class - String class 를 제공한다. 
String class는 문자열을 저장하고, 다루기 위한 함수를 제공한다. 

변경 불가능한(immutable) 클래스
public final class String implements java.io.Serializable, comparable {
	private char[] value;
	...
}

문자열 비교
문자열을 만들 때는 두가지 방법이 존재 ( 문자열 리터럴을 지정하는 방법과 , String클래스의 생성자를 이용해서 만드는 방법)
String str1 = "abc" ;  // 문자열 리터럴 "abc"의 주소가 str1에 저장됨.
String str2 = "abc" ; // 문자열 리터럴 "abc"의 주소가 str2에 저장됨.
String str3 = new String("abc"); // 새로운 String instance를 생성
String str4 = new String("abc"); // 새로운 String instance를 생성
문자열 리터럴은 이미 존재하는 것을 재사용하는 것이며 , New 생성자는 instance를 새로 메모리에 만들어 주는 역할을 한다. 

equals() 를 사용하면 두 문자열의 내용을 비굑하기 때문에 리터럴과 new 모두 true로 나타낸다. 
그러나 String instance의 주소를 등가비교연산자 '=='로 비교했을 때는 결과가 다르다. 

문자열 리터럴
자소 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 이 때 같은 내용의 문자열 리터럴은 한번만 저장된다. 
문자열 리터럴도 String instance이고 한번 생성하면 내용을 변경할 수 없으니 하나의 인스턴스를 공유하면 되기 때문이다. 

빈 문자열(empty string)

